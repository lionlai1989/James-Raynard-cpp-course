/**
 * Virtual Destructor:
 * The memory layout of Base class and Derived class objects
 *
 *               ---------------------------
 *   base_ptr--> |   Base   |              |
 *               ---------------------------
 *               <---      Derived      --->
 * ```cpp
 * Shape *shape = new Circle;
 * delete shape;
 * ```
 *
 * Which destructor(s) is called when deleting `shape`?
 */
#include <iostream>
#include <vector>

using namespace std;

class Shape {
  public:
    virtual void draw() const { cout << "Drawing a generic shape...\n"; }
    ~Shape() { cout << "Goodbye from Shape object!\n"; }
};
class Circle : public Shape {
  public:
    // Is it an override or overload function?
    // It's an overload because it has a different signature than Shape::draw().
    void draw() { cout << "Drawing a circle...\n"; }

    ~Circle() { cout << "Goodbye from Circle object!\n"; }
};
/**
 * If the destructor in the base class is not virtual, static binding is used to call the
 * destructor, resulting in only the base class destructor being executed. This can lead to
 * resource leaks if the derived class allocated resources that need to be released.
 *
 * We need to use dynamic binding for destructors.
 *
 * Also, if we do not define a destructor in the base class, the compiler will synthesize a default
 * destructor. The default destructor generated by the compiler is NON-virtual.
 *
 * We can prevent this by explicitly declaring a virtual destructor in the base class.
 * ```
 * virtual ~Shape() = default;
 * ```
 *
 * In general, if a class has any virtual functions, it should also have a virtual destructor.
 */

class Shape2 {
  public:
    virtual void draw() const { cout << "Drawing a generic shape...\n"; }
    virtual ~Shape2() { cout << "Goodbye from Shape2 object!\n"; }
};
class Circle2 : public Shape2 {
  public:
    // It is an override function because it has the same signature as Shape2::draw().
    // Always use `override` keyword for overridden functions to make compiler check for you.
    void draw() const override { cout << "Drawing a circle...\n"; }
    ~Circle2() { cout << "Goodbye from Circle2 object!\n"; }
};

// g++ -std=c++20 -Wall -Wextra -pedantic 133-virtual_destructor.cpp && ./a.out
int main() {
    vector<Shape *> shapes; // Vector of pointers to Shape
    shapes.push_back(new Circle);
    for (auto shape : shapes)
        shape->draw(); // Dynamic binding to Circle::draw()
    for (auto shape : shapes)
        // warning: deleting object of polymorphic class type ‘Shape’ which has non-virtual
        // destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
        delete shape; // Which version of destructor is called?
    /**
     * Output:
     * ---------------
     * Drawing a generic shape...
     * Goodbye from Shape object!
     */

    cout << "---------------------\n";

    vector<Shape2 *> shapes2; // Vector of pointers to Shape2
    shapes2.push_back(new Circle2);
    for (auto shape : shapes2)
        shape->draw(); // Dynamic binding to Circle::draw()
    for (auto shape : shapes2)
        delete shape; // Which version of destructor is called?
    /**
     * Output: Notice the order of destructor calls
     * ---------------
     * Drawing a circle...
     * Goodbye from Circle2 object!
     * Goodbye from Shape2 object!
     */

    return 0;
}